spring.application.name=API_Server

# Local PostgreSQL Database Configuration
spring.datasource.local.url=jdbc:postgresql://localhost:5432/marketmonitor
spring.datasource.local.username=sunny
spring.datasource.local.password=${DB_PASSWORD}
spring.datasource.local.driver-class-name=org.postgresql.Driver

# Supabase PostgreSQL Database Configuration
spring.datasource.supabase.url=jdbc:postgresql://${SUPABASE_HOST}:5432/postgres
spring.datasource.supabase.username=postgres
spring.datasource.supabase.password=${SUPABASE_PASSWORD}
spring.datasource.supabase.driver-class-name=org.postgresql.Driver

# JPA Configuration (applied per-datasource in config classes)
spring.jpa.open-in-view=false

# Azure Function URL
azure.function.url=http://localhost:7071/api/MarketDataFunction
azure.function.base-url=http://localhost:7071/api

# WebClient timeout settings (milliseconds)
webclient.timeout.connect=5000
webclient.timeout.read=10000

# Cache configuration (60 seconds TTL, max 100 entries)
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=100,expireAfterWrite=60s

# Circuit Breaker configuration
resilience4j.circuitbreaker.instances.marketData.slidingWindowSize=10
resilience4j.circuitbreaker.instances.marketData.failureRateThreshold=50
resilience4j.circuitbreaker.instances.marketData.waitDurationInOpenState=30s
resilience4j.circuitbreaker.instances.marketData.permittedNumberOfCallsInHalfOpenState=3

resilience4j.circuitbreaker.instances.historicalData.slidingWindowSize=10
resilience4j.circuitbreaker.instances.historicalData.failureRateThreshold=50
resilience4j.circuitbreaker.instances.historicalData.waitDurationInOpenState=30s
resilience4j.circuitbreaker.instances.historicalData.permittedNumberOfCallsInHalfOpenState=3

# Rate Limiter configuration (10 requests per second)
resilience4j.ratelimiter.instances.marketDataApi.limitForPeriod=10
resilience4j.ratelimiter.instances.marketDataApi.limitRefreshPeriod=1s
resilience4j.ratelimiter.instances.marketDataApi.timeoutDuration=0s
